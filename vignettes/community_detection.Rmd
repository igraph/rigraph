---
title: "Community Detection"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Community Detection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE, warning = FALSE}
library(igraph)
```


```{r example_graph, echo = FALSE}
set.seed(1234)
g <- sample_islands(5, 20, 0.9, 5)
g <- simplify(g)

colors <- c("red", "green", "blue", "yellow", "purple")

V(g)$color <- rep(colors, each = 20)
plot(g, vertex.label = NA, vertex.size = 5)
```

```{r algos, echo = FALSE, message = FALSE}
algs <- as.character(lsf.str("package:igraph"))
algs[grepl("cluster_", algs)]
```

Most of these algorithms are based on the so called "modularity maximization". 
Modularity measures how well a network can be divided into distinct groups, where nodes within the same group are more densely connected to each other than to nodes in other groups. 
The modularity score compares the actual density of links within communities to the expected density if the links were randomly distributed. 
A higher modularity value indicates a stronger community structure. 
This approach is widely used in social networks, biology, and other fields to uncover meaningful groupings in complex systems.

The workflow of a cluster analysis is always the same, independent from the chosen method. We illustrate the workflow using the infamous karate club network.

```{r karate}
karate <- make_graph("Zachary")
plot(karate)
```

Below we illustrate the workflow using the `cluster_louvain()` function, which is one of the most commonly used clustering algorithms in igraph.

```{r cluster_ex}
# compute clustering
clu <- cluster_louvain(karate)

# cluster membership vector
mem <- membership(clu)
mem

# clusters as list
com <- communities(clu)
com
```

To compare the quality of clusterings, we can compute the modularity score for each output.

```{r karate-cluster}

imc <- cluster_infomap(karate)
lec <- cluster_leading_eigen(karate)
loc <- cluster_louvain(karate)
sgc <- cluster_spinglass(karate)
wtc <- cluster_walktrap(karate)

scores <- c(
  infomap = modularity(karate, membership(imc)),
  eigen = modularity(karate, membership(lec)),
  louvain = modularity(karate, membership(loc)),
  spinglass = modularity(karate, membership(sgc)),
  walk = modularity(karate, membership(wtc))
)
scores
```

For the karate network, `cluster_spinglass()` produces the highest modularity score.

Modularity maximization is still widely considered as the state-of-the-art clustering method
for networks. There are, however, some technical shortcomings that one should be aware of.
One of those is the so called "resolution limit". When modularity is being maximized, it can happen
that smaller clusters are merged together to form bigger clusters. The prime example is the graph that
consists of cliques connected in a ring.

```{r prepare-Kn-graph, echo = FALSE, message = FALSE}
n1 <- 5
n2 <- 50
A <- matrix(1, n1, n1)
lst <- vector("list", n2)
lst <- lapply(lst, function(x) A)
AA <- Matrix::bdiag(lst)
for (i in 1:(n2 - 1)) {
  AA[i * n1, i * n1 + 1] <- AA[i * n1 + 1, i * n1] <- 1
}
AA[1, n1 * n2] <- AA[n1 * n2, 1] <- 1
K50 <- graph_from_adjacency_matrix(AA, "undirected", diag = FALSE)
```

The figure below shows such a graph, consisting of 50 cliques of size 5. 

```{r plot-K50-blank, echo = FALSE, message = FALSE}
plot(K50, vertex.label = NA, vertex.size = 2, edge.color = "grey66")
```

Intuitively, any clustering method should return a cluster for each clique.
But as the table below shows, the clustering methods based on modularity maximization do not return the expected result but rather merge neighboring cliques together.

```{r clu-louvain-K50}
clu_louvain <- cluster_louvain(K50)
table(membership(clu_louvain))
```

A clustering algorithm that fixes this issue is the leiden algorithm which, by default, uses the "CPM" objective function instead of modularity.

```{r}
#| label: clu-leiden-K50
clu_leiden <- cluster_leiden(
  K50,
  objective_function = "CPM",
  resolution = 0.5
)
table(membership(clu_leiden))
```

The `resolution` parameter controls the granularity of the clustering. A higher resolution leads to smaller clusters, while a lower resolution results in larger clusters. The optimal value often depends on the specific structure of the graph and the research question at hand.

A reasonable starting point for the parameter is to use the average edge strength of the graph divided by the number of vertices minus one. 

```r
quantile(strength(g))[2] / (gorder(g) - 1)
```


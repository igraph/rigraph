# igraph/tools

## Updating the sources

In the shell:

```sh
./vendor.sh <path-to-cigraph-working-copy>
```

By default, `cigraph` is assumed to be in `../../../igraph`.

There is a CI/CD workflow that runs this very frequently.

## Running Stimulus

Currently, there are only two files generated by Stimulus.
They are version-controlled and depend on various input files.
The logic is governed by the `Makefile-cigraph` file.
To update them, do the following steps:

```sh
make -f Makefile-cigraph src/rinterface.c R/aaa-auto.R
```

## Managing Stimulus with git subrepo

### What is git subrepo?

The Stimulus code generator is vendored into this repository using [`git subrepo`](https://github.com/ingydotnet/git-subrepo), a tool that allows you to include an external git repository as a subdirectory within your main repository.
Unlike git submodules, subrepos are easier to work with because they don't require special checkout commands; the code is directly present in the repository.
This approach gives us the flexibility to test local modifications to Stimulus while still being able to pull upstream updates cleanly.

### Installing git subrepo

If you don't have `git subrepo` installed yet:

```sh
# On macOS with Homebrew
brew install git-subrepo

# Or install from source
git clone https://github.com/ingydotnet/git-subrepo /path/to/git-subrepo
echo 'source /path/to/git-subrepo/.rc' >> ~/.zshrc
```

### Updating Stimulus from upstream

To pull the latest changes from the upstream Stimulus repository:

```sh
# Pull the latest from the main branch
git subrepo pull tools/py-stimulus

# Or pull a specific branch
git subrepo pull tools/py-stimulus -b branch-name

# Or pull a specific commit or tag
git subrepo pull tools/py-stimulus -b v0.21.5
```

This command will:

1. Fetch changes from the upstream Stimulus repository
2. Merge them into the `tools/py-stimulus/` directory
3. Create a merge commit with metadata in `.gitrepo`
4. Update the commit hash in `tools/py-stimulus/.gitrepo`

After pulling, test the changes:

```sh
# Clean the virtualenv to ensure fresh installation
rm -rf .venv

# Regenerate the interface files
make -f Makefile-cigraph src/rinterface.c R/aaa-auto.R
```

### Working with a modified version of Stimulus

If you need to test local changes to Stimulus:

1. **Make your changes** directly in `tools/py-stimulus/`:

   ```sh
   cd tools/py-stimulus
   # Edit files as needed
   vim src/stimulus/some_file.py
   cd ../..
   ```

2. **Test your changes**:

   ```sh
   # Remove the virtualenv to force reinstallation
   rm -rf .venv

   # Regenerate with your modified Stimulus
   make -f Makefile-cigraph src/rinterface.c R/aaa-auto.R
   ```

3. **Commit everything together**:

   ```sh
   git add tools/py-stimulus/ src/rinterface.c R/aaa-auto.R
   git commit -m "feat: update Stimulus and regenerated interface files"
   ```

The modified Stimulus code and generated files will be committed together, making it easy to see what Stimulus changes caused which interface changes.

### Pushing Stimulus changes upstream

If your Stimulus modifications should be contributed back to the upstream repository:

```sh
# Push your changes to the upstream Stimulus repository
git subrepo push tools/py-stimulus

# Or push to a specific branch (useful for PRs)
git subrepo push tools/py-stimulus -b feature-branch-name
```

This will create commits in the upstream Stimulus repository based on the commits you made in `tools/py-stimulus/`.

### Checking subrepo status

To see information about the subrepo:

```sh
git subrepo status tools/py-stimulus
```

This shows the remote URL, branch, and commit hashes.

## Implementing R Wrappers for Callback Functions

This section documents the pattern for implementing R wrappers for C callback functions using the closure-based approach. This pattern was established in PR #2465 and extended to all callback functions in a subsequent PR.

### Overview

igraph C library uses callbacks for functions that can produce large result sets (e.g., finding all cliques, cycles, isomorphisms). The callback pattern allows processing results incrementally without storing everything in memory. Our R interface provides an ergonomic wrapper that accepts R functions as callbacks.

### Architecture

The implementation has three layers:

1. **C Handler** (`src/rcallback.c`): Converts C types to R types with proper indexing
2. **Closure Bridge** (`src/rcallback.c`): Connects R callbacks to C handlers via `void* extra`
3. **Autogenerated Interface** (`R/aaa-auto.R`, `src/rinterface.c`): Parameter validation and `.Call()` invocation
4. **R Wrapper** (e.g., `R/cliques.R`): User-facing function with documentation

### Step-by-Step Implementation Guide

#### 1. Identify the C Callback Function

Find the function signature in `src/vendor/cigraph/interfaces/functions.yaml`:

```yaml
igraph_cliques_callback:
    PARAMS: |-
        GRAPH graph, INTEGER min_size=0, INTEGER max_size=0,
        CLIQUE_FUNC cliquehandler_fn, OPTIONAL EXTRA arg
```

Identify the callback type (e.g., `CLIQUE_FUNC`) and check its signature in `types.yaml`.

#### 2. Add C Handler Function

In `src/rcallback.c`, create a handler that converts C types to R types:

```c
/* Handler function for clique callbacks - converts C types to R types */
igraph_error_t R_igraph_clique_handler(const igraph_vector_int_t *clique, void *extra) {
  R_igraph_callback_data_t *data = (R_igraph_callback_data_t *)extra;
  SEXP callback = data->callback;
  SEXP clique_r, R_fcall, result;
  igraph_bool_t cres;

  /* Create R vector for clique (add 1 for R's 1-based indexing) */
  PROTECT(clique_r = NEW_INTEGER(igraph_vector_int_size(clique)));
  for (igraph_integer_t i = 0; i < igraph_vector_int_size(clique); i++) {
    INTEGER(clique_r)[i] = igraph_vector_int_get(clique, i) + 1;
  }

  /* Call the R function: callback(clique) */
  PROTECT(R_fcall = Rf_lang2(callback, clique_r));
  PROTECT(result = Rf_eval(R_fcall, R_GlobalEnv));
  
  /* Check if result is an error condition (from tryCatch) */
  if (Rf_inherits(result, "error")) {
    UNPROTECT(3);
    igraph_error("Error in R callback function", __FILE__, __LINE__, IGRAPH_FAILURE);
    return IGRAPH_FAILURE;
  }
  
  cres = Rf_asLogical(result);
  UNPROTECT(3);
  
  /* R callback returns TRUE to continue, FALSE to stop */
  return cres ? IGRAPH_SUCCESS : IGRAPH_STOP;
}
```

**Key points:**
- Use `igraph_vector_int_get()` to access vector elements (not `VECTOR()` macro)
- Add 1 for R's 1-based indexing
- Handle errors from R callbacks via `tryCatch` wrapper
- Return `IGRAPH_SUCCESS` to continue, `IGRAPH_STOP` to stop

#### 3. Add Closure Bridge Function

In `src/rcallback.c`, create a closure function that connects the R callback to the handler:

```c
/* Closure function for cliques_callback */
igraph_error_t igraph_cliques_callback_closure(
    const igraph_t *graph,
    igraph_integer_t min_size,
    igraph_integer_t max_size,
    SEXP callback) {
  
  R_igraph_callback_data_t data = { .callback = callback };
  
  return igraph_cliques_callback(
      graph, min_size, max_size,
      R_igraph_clique_handler, &data);
}
```

#### 4. Declare Functions in Header

Add declarations to `src/rinterface.h`:

```c
/* Cliques */
igraph_error_t R_igraph_clique_handler(const igraph_vector_int_t *clique, void *extra);

igraph_error_t igraph_cliques_callback_closure(
    const igraph_t *graph,
    igraph_integer_t min_size,
    igraph_integer_t max_size,
    SEXP callback);
```

#### 5. Configure Stimulus

In `tools/stimulus/functions-R.yaml`, mark the original callback function as ignored and add the closure version:

```yaml
igraph_cliques_callback:
    # Has callback parameter
    IGNORE: RR, RC, RInit

igraph_cliques_callback_closure:
    PARAMS: |-
        GRAPH graph, INTEGER min_size=0, INTEGER max_size=0,
        CLOSURE callback
```

The `CLOSURE` type is already defined in `tools/stimulus/types-RC.yaml` and `types-RR.yaml`. It automatically:
- Validates that the argument is a function
- Wraps the callback in `tryCatch()` for error handling

#### 6. Regenerate Autogenerated Files

Run Stimulus to generate the interface:

```sh
make -f Makefile-cigraph src/rinterface.c R/aaa-auto.R
```

This creates:
- `*_callback_closure_impl()` function in `R/aaa-auto.R`
- `R_igraph_*_callback_closure()` function in `src/rinterface.c`

#### 7. Register in cpp11.cpp

Add extern declaration and registration entry in `src/cpp11.cpp`:

```c
// In extern declarations section:
extern SEXP R_igraph_cliques_callback_closure(SEXP, SEXP, SEXP, SEXP);

// In CallEntries array:
{"R_igraph_cliques_callback_closure", (DL_FUNC) &R_igraph_cliques_callback_closure, 4},
```

#### 8. Create R Wrapper Function

In the appropriate R file (e.g., `R/cliques.R`), create a user-facing wrapper:

```r
#' Find cliques with a callback function
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' This function searches for cliques in a graph and calls a user-provided
#' callback function for each clique found.
#'
#' @param graph The input graph.
#' @param min Lower limit on clique size. `NULL` means no limit (same as 0).
#' @param max Upper limit on clique size. `NULL` means no limit.
#' @param callback A function to call for each clique found. The function
#'   should accept one argument: `clique` (integer vector of vertex IDs,
#'   1-based indexing). Return `TRUE` to continue the search or `FALSE` to stop.
#' @return `NULL`, invisibly. Called for side effects.
#' @seealso [cliques()], [max_cliques()]
#'
#' @export
#' @family cliques
#' @cdocs igraph_cliques_callback
#'
#' @examples
#' g <- sample_gnp(20, 0.3)
#' count <- 0
#' cliques_callback(g, min = 3, max = 4, callback = function(clique) {
#'   count <<- count + 1
#'   TRUE  # continue search
#' })
cliques_callback <- function(graph, min = NULL, max = NULL, callback) {
  ensure_igraph(graph)
  
  if (is.null(min)) min <- 0
  if (is.null(max)) max <- 0

  cliques_callback_closure_impl(
    graph = graph,
    min_size = min,
    max_size = max,
    callback = callback
  )

  invisible(NULL)
}
```

**Key points:**
- Mark as experimental with lifecycle badge
- Document callback signature clearly
- Include comprehensive examples
- Handle NULL defaults for optional parameters
- Call the autogenerated `*_closure_impl()` function
- Return `invisible(NULL)` for consistency

#### 9. Write Tests

Add tests in two locations:

**A. Tests for `_impl` function in `tests/testthat/test-aaa-auto.R`:**

```r
test_that("cliques_callback_closure_impl basic", {
  withr::local_seed(20250909)
  local_igraph_options(print.id = FALSE)
  
  g <- make_full_graph(4)
  
  # Collect clique information for snapshot
  clique_data <- list()
  result <- cliques_callback_closure_impl(
    graph = g,
    min_size = 3,
    max_size = 4,
    callback = function(clique) {
      clique_data[[length(clique_data) + 1]] <<- clique
      TRUE
    }
  )
  
  expect_snapshot({
    cat("Result:\n")
    print(result)
    cat("\nNumber of cliques found:", length(clique_data), "\n")
    cat("First clique:\n")
    print(clique_data[[1]])
  })
  
  # Structured tests
  expect_null(result)
  expect_true(length(clique_data) > 0)
  expect_true(is.integer(clique_data[[1]]))
  expect_true(length(clique_data[[1]]) >= 3)
  expect_true(length(clique_data[[1]]) <= 4)
})

test_that("cliques_callback_closure_impl errors", {
  withr::local_seed(20250909)
  local_igraph_options(print.id = FALSE)
  
  g <- make_full_graph(4)
  
  expect_snapshot_igraph_error(
    cliques_callback_closure_impl(
      graph = g,
      min_size = 3,
      max_size = 4,
      callback = "not a function"
    )
  )
})
```

**B. Tests for wrapper function in appropriate file (e.g., `tests/testthat/test-cliques.R`):**

```r
test_that("cliques_callback works", {
  withr::local_seed(123)
  g <- sample_gnp(20, 0.3)
  
  count <- 0
  cliques_callback(g, min = 3, max = 4, callback = function(clique) {
    count <<- count + 1
    TRUE
  })
  
  expect_true(count > 0)
})

test_that("cliques_callback can stop early", {
  # Test early stopping by returning FALSE
})

test_that("cliques_callback receives correct arguments", {
  # Test callback signature and types
})

test_that("cliques_callback handles errors in callback", {
  # Test error handling
})
```

### Common Pitfalls

1. **Vector Access**: Always use `igraph_vector_int_get(vec, i)`, not `VECTOR(*vec)[i]`
2. **Indexing**: Remember to add 1 for R's 1-based indexing
3. **UNPROTECT**: Match PROTECT calls with UNPROTECT (count carefully!)
4. **Error Handling**: Check for errors from R callbacks via `Rf_inherits(result, "error")`
5. **Return Values**: `TRUE` continues, `FALSE` stops early
6. **Test Location**: `_impl` tests go in `test-aaa-auto.R`, wrapper tests in feature files

### Testing Pattern

- Use `withr::local_seed(20250909)` for reproducibility
- Use `local_igraph_options(print.id = FALSE)` for stable snapshots
- Both snapshot tests (`expect_snapshot`) and structured tests (`expect_*`)
- Test basic functionality, early stopping, error handling, and argument types

### References

- Original implementation: PR #2465 (motifs_randesu_callback)
- Complete implementation: PR #XXXX (all callback functions)
- Stimulus documentation: `tools/py-stimulus/README.md`

